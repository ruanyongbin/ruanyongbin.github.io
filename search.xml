<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>找出满足条件的三元组</title>
      <link href="/2021/09/25/%E6%89%BE%E5%87%BA%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/"/>
      <url>/2021/09/25/%E6%89%BE%E5%87%BA%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<hr><ul><li><p>题目描述</p><blockquote><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。</p></blockquote></li><li><p>注意</p><blockquote><p>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）<br>解集中不能包含重复的三元组。</p></blockquote></li><li><p>例如</p><blockquote><p>给定的数组 S = {-10 0 10 20 -10 -40},解集为(-10, 0, 10) (-10, -10, 20)</p></blockquote></li><li><p>解题思路</p><blockquote><p>先排序，然后外层循环 固定开始元素1 ，设置 两个指针，一个指针start指向元素2（元素2初始为元素1的下一个），一个指针end指向元素3（元素3初始为最后一个）<br>内层循环（能找到3个元素条件start&lt;end，这里保证所有的组合都能找到）根据 3个元素的值 进行调整、判断是否符合，符合就加入集合，不符合就根据 大于、小于 0 的情况移动start、end指针</p></blockquote></li><li><p>代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num)&#123;</span><br><span class="line">        <span class="comment">//结果集合</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();       </span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="comment">//从 第一个元素到 倒数第二个元素，外层循环配合内层循环 判断 含当前元素的每种情况，内层循环筛选符合条件的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num.length - <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 当前元素的下一个元素</span></span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//最后一个元素</span></span><br><span class="line">            <span class="keyword">int</span> end = num.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//还够3个元素</span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                <span class="comment">//此轮的三个元素和</span></span><br><span class="line">                <span class="keyword">int</span> sum = num[i] + num[start] + num[end];</span><br><span class="line">                <span class="comment">//因为已经排好序，需要向移动下标向0靠近</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//需要中间指针更大的值</span></span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//需要末尾指针更小的值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等于 0 的情况，添加小集合到 大集合中</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                     ArrayList&lt;Integer&gt; list_small = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    </span><br><span class="line">                    list_small.add(num[i]);</span><br><span class="line">                    list_small.add(num[start]);</span><br><span class="line">                    list_small.add(num[end]);</span><br><span class="line">                    <span class="keyword">if</span>(!list.contains(list_small))&#123;</span><br><span class="line">                        list.add(list_small);</span><br><span class="line">                       </span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//继续判断 是否还有含 num[i] 的不同组合</span></span><br><span class="line">                    start++;</span><br><span class="line">                    end--;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br/><br/><br/>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 4399 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4399校招面经</title>
      <link href="/2021/09/25/4399%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
      <url>/2021/09/25/4399%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="某团队2-5的人会Java，3-4的人会C-，团队里同时会Java和C-的最少有（-）人"><a href="#某团队2-5的人会Java，3-4的人会C-，团队里同时会Java和C-的最少有（-）人" class="headerlink" title="某团队2/5的人会Java，3/4的人会C++，团队里同时会Java和C++的最少有（ ）人"></a>某团队2/5的人会Java，3/4的人会C++，团队里同时会Java和C++的最少有（ ）人</h3><blockquote><p>5和4求最小公倍数20，此团队至少为20人，会java的至少8人，会c++的至少15人</p><p>假设团队有20人每人只会一种的话 15+8=23人，而团队20人，则有3人俩种都会，则至少3人</p></blockquote><hr><h3 id="下面代码运行的结果？"><a href="#下面代码运行的结果？" class="headerlink" title="下面代码运行的结果？"></a>下面代码运行的结果？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><h3 id="TCP-IP模型如何分层？路由器、网卡分别属于哪一层？"><a href="#TCP-IP模型如何分层？路由器、网卡分别属于哪一层？" class="headerlink" title="TCP/IP模型如何分层？路由器、网卡分别属于哪一层？"></a>TCP/IP模型如何分层？路由器、网卡分别属于哪一层？</h3><blockquote><p>TCP/IP被设计成四层概念模型：应用层，传输层，网际层（相当于网络层）和网络接口层（相当于数据链路层和物理层）</p></blockquote><table><thead><tr><th align="center">OSI层次</th><th align="center">地址类型——–设备</th></tr></thead><tbody><tr><td align="center">传输层及以上</td><td align="center">应用程序进程地址（端口）———网关（协议转换器）</td></tr><tr><td align="center">网络层</td><td align="center">网络地址（IP地址）————路由器（三层交换机）</td></tr><tr><td align="center">数据链路层</td><td align="center">物理地址）（MAC地址）————网桥，交换机（网卡）</td></tr><tr><td align="center">物理层</td><td align="center">无————中继器，集线器（网卡）</td></tr></tbody></table><hr><h3 id="为什么要使用微服务"><a href="#为什么要使用微服务" class="headerlink" title="为什么要使用微服务?"></a>为什么要使用微服务?</h3><blockquote><p>单体模式 vs 微服务</p><p>单体服务的缺点？</p><ul><li>难以扩展</li><li>交付时间长</li><li>应用复杂性</li><li>故障级联</li><li>陷入某种技术/语言</li></ul><p>微服务能够较好地解决以上问题。</p></blockquote><hr><br/><br/><br/>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 4399 </tag>
            
            <tag> Java后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0～n-1中缺失的数字</title>
      <link href="/2021/09/13/0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/09/13/0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 10000</code></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><blockquote><p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p></blockquote><p>题目的可以理解为：<strong>找出第一个 索引和索引上的值不匹配 的索引。</strong></p><p>根据题意<strong>排序且不重复</strong>我们利用二分法，如果数组下标 mid 和 nums[mid] 相同的话，mid之前的元素都是存在的。这样就能减小范围，直到找到第一个索引和索引上的值不匹配的元素，如果所有位置都匹配的话，就是缺少nums.length这个数。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left==nums[left]?left+<span class="number">1</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length-<span class="number">1</span> == nums[nums.length -<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/><br/><br/></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在排序数组中查找数字 I</title>
      <link href="/2021/09/13/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/"/>
      <url>/2021/09/13/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/</url>
      
        <content type="html"><![CDATA[<p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><blockquote><p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p></blockquote><p>找到一个target的位置，然后统计数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//int mid = (left+right)/2;</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; nums.length &amp;&amp; nums[left] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="灵魂在这"><a href="#灵魂在这" class="headerlink" title="灵魂在这:"></a>灵魂在这:</h4><p>nums[mid] &lt; target,此处左边界绝不能等于;只有右边界能等于;由右边界确定大致范围,</p><p>如果存在target的话，那么nums[left]就必定是一个target的位置，最后再从左至右遍历!!!</p><br/><br/><br/>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="/2021/09/13/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/09/13/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure><h3 id="解题方法："><a href="#解题方法：" class="headerlink" title="解题方法："></a><strong>解题方法：</strong></h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>暴力解法，直接两重for循环找出重复数字。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>先进行排序，排序完成后，两两比较，如果一样就能找出重复数字。</p><h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>把数组中的元素存入集合中，如果放不下的就是重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h4><p>这种原地置换的想法确实挺精妙的。</p><p>1、题目明确说明了数组长度为n，范围为 n-1，也就是若无重复元素排序后下标0123对应的数字就应该是0123；</p><p>2、对数组排序，其实也就是让萝卜归位，1号坑要放1号萝卜，2号坑要放2号萝卜……排序过程中查找有无重复元素。先考虑没有重复元素的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums[i]     3  1  0  2   萝卜   </span><br><span class="line">    i       0  1  2  3   坑</span><br></pre></td></tr></table></figure><p>0号坑说我要的是0号萝卜，不要3号萝卜，所以会去和3号坑的萝卜交换，因为如果0号坑拿了3号坑的3号萝卜，那说明3号坑装的也肯定是别人家的萝卜，所以要跟3号坑换，换完是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums[i]     2  1  0  3   萝卜  </span><br><span class="line">    i       0  1  2  3   坑 </span><br></pre></td></tr></table></figure><p>然而0号坑还没找到自己的萝卜，它不要2号萝卜，又去和2号坑的萝卜交换，换完是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nums[i]</span>     <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>   <span class="string">萝卜</span> </span><br><span class="line">    <span class="string">i</span>       <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>   <span class="string">坑</span>  </span><br></pre></td></tr></table></figure><p>这时候刚好就是一一对应的，交换过程也不会出现不同坑有相同编号的萝卜。要注意交换用的是while，也就是0号坑只有拿到0号萝卜，1号坑才能开始找自己的萝卜。</p><p>3、如果有重复元素，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nums[i]</span>     <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">2</span>    <span class="string">萝卜</span></span><br><span class="line">    <span class="string">i</span>       <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>    <span class="string">坑</span></span><br></pre></td></tr></table></figure><p>同样的，0号坑不要1号，先和1号坑交换，交换完这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nums[i]</span>     <span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">2</span>    <span class="string">萝卜</span></span><br><span class="line">    <span class="string">i</span>       <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>    <span class="string">坑</span></span><br></pre></td></tr></table></figure><p>0号坑不要2号萝卜，去和2号坑交换，交换完这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nums[i]</span>     <span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>    <span class="string">萝卜</span></span><br><span class="line">    <span class="string">i</span>       <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>    <span class="string">坑</span></span><br></pre></td></tr></table></figure><p>0号坑不要3号萝卜，去和3号坑交换，交换完这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nums[i]</span>     <span class="number">2</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>    <span class="string">萝卜</span></span><br><span class="line">    <span class="string">i</span>       <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>    <span class="string">坑</span></span><br></pre></td></tr></table></figure><p>0号坑不要2号萝卜，去和2号坑交换，结果发现你2号坑也是2号萝卜，那我还换个锤子，同时也说明有重复元素出现。</p><p>4、总结</p><p>其实这种原地交换就是为了降低空间复杂度，只需多要1个坑来周转交换的萝卜就好了，空间复杂度O（1）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[nums[i]];</span><br><span class="line">                nums[nums[i]] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><br/><br/>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
